#!/bin/bash

PLATFORM="$(uname)"
if [[ -z "$HOSTNAME" ]]; then
    HOSTNAME=$(hostname -s)-$RANDOM
fi

if [[ -z "$WEBMUX_HOST" ]]; then
    WEBMUX_HOST="webmux.e.ip.saba.us"
fi
if [[ -z "$WEBMUX_PORT" ]]; then
    WEBMUX_PORT=2000
fi
if [[ -z "$WEBMUX_SSH_KEY_FILE" ]]; then
    WEBMUX_SSH_KEY_FILE="$HOME/etc/secure/ssh/external/webmux_rsa"
fi
chmod 0600 "$WEBMUX_SSH_KEY_FILE"

KEYSCAN="[|1|9UJGBoc3H5go/V3jv1otiSyxO5g=|/dS3fFmFq8ekOGtbP82gD2DE+8Q=]:2000 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBAxveddAVoQP70xoveM966s80WjqDQyKzSY6RNQDdp5W2O0GlcxxNVFKypaAHl8EmIVA1Zi/ISl0LRGuGrIPCXY="
if [[ -z $(grep "$KEYSCAN" $HOME/.ssh/known_hosts) ]]; then
    echo "$KEYSCAN" >> "$HOME/.ssh/known_hosts"
fi

function qwhich()
{
    which "$@" 2>/dev/null
}

# Returns true (0) if we've got a `mosh-server` and a `socat` on the path
function can_mosh
{
    if [[ -n "$(qwhich mosh-server)" ]] && [[ -n "$(qwhich socat)" ]]; then
        return 0
    fi
    return 1
}

function get_port_mapping()
{
    MOSH_PATH=""
    if can_mosh; then
        MOSH_PATH="$(qwhich mosh-server)"
    fi
    JSON_DATA="{\"user\":\"$USER\", \"hostname\":\"$HOSTNAME\", \"mosh_path\":\"$MOSH_PATH\"}"
    curl -# -H "Content-Type: application/json" -X POST -d "$JSON_DATA" -f -L "https://$WEBMUX_HOST/register"
}

function webmux_reverse_tunnel()
{
    SSH_PORT="$1"
    MOSH_PORT="$(($1 + 1000))"

    # Use a "timeout" command, if we can, if we can't, well, too bad
    TIMEOUT=""
    if [[ -n "$(qwhich gtimeout)" ]]; then
        TIMEOUT="$(qwhich gtimeout) 1h"
    elif [[ -n "$(qwhich timeout)" ]]; then
        TIMEOUT="$(qwhich timeout) 1h"
    fi

    # Initialize SSH_CMD with our timeout
    SSH_CMD="$TIMEOUT $(which ssh)"

    # Set keyfile to use to login
    SSH_CMD="$SSH_CMD -i ${WEBMUX_SSH_KEY_FILE/#\~/$HOME}"

    # Create port forwarding for SSH
    SSH_CMD="$SSH_CMD -R $SSH_PORT:localhost:22"

    # If we can tunnel mosh, then start up a socat instance running on here to
    # parrot incoming UDP-over-TCP packets to our mosh instance
    if can_mosh; then
        SSH_CMD="$SSH_CMD -R $MOSH_PORT:localhost:$MOSH_PORT"

        # Immediately spawn off our own socat to do the local parroting
        SOCAT_CMD="$TIMEOUT socat tcp4-listen:$MOSH_PORT,reuseaddr,fork udp:localhost:$MOSH_PORT"
        $SOCAT_CMD &
        SOCAT_PID="$!"
    fi

    # Put in server address
    SSH_CMD="$SSH_CMD -N -p $WEBMUX_PORT webmux@$WEBMUX_HOST"


    # Execute the SSH command
    $SSH_CMD

    # Once ssh finishes, immediately kill the socat if it's still there
    if [[ -n "$SOCAT_PID" ]] && [[ "$(ps -o command -p $SOCAT_PID)" == *$SOCAT_CMD* ]]; then
        echo "Killing child socat..."
        kill $SOCAT_PID
    fi
}

if [[ -z "$(qwhich timeout)" ]] && [[ -z "$(qwhich gtimeout)" ]]; then
    if [[ "$PLATFORM" == "Darwin" ]]; then
        brew install coreutils
    elif [[ -n "$(qwhich apt-get)" ]]; then
        sudo apt-get install coreutils
    elif [[ -n "$(qwhich yum)" ]]; then
        sudo yum install coreutils
    else
        echo "`timeout` not found, and I don't know how to install it, continuing without!"
    fi
fi

while [ true ]; do
    PORT_NUMBER=$(get_port_mapping)
    if [[ -z "$PORT_NUMBER" ]]; then
        echo "ERROR: Could not get port mapping; git pull'ing and trying again..."
        git pull
        sleep 10
        exec "./webmux_client"
    fi
    echo "Connecting to claim port $PORT_NUMBER..."
    webmux_reverse_tunnel $PORT_NUMBER
    sleep 1
done
