#!/bin/bash

function decrypted()
{
    [[ -f "$1" ]] && [[ $(head -c 10 "$1") != "GITCRYPT" ]]
}

function get_ip()
{
    if [[ "${PLATFORM}" == "Linux" ]]; then
        getent hosts $1 | awk '{ print $1 }'
    elif [[ "${PLATFORM}" == "Darwin" ]]; then
        dscacheutil -q host -a name $1 | grep ip_address | cut -d: -f2 | xargs echo
    fi
}

PLATFORM="$(uname)"
if [[ -z "$HOSTNAME" ]]; then
    HOSTNAME=$(hostname -s)-$RANDOM
fi

if [[ -z "$WEBMUX_HOST" ]]; then
    WEBMUX_HOST="webmux.e.ip.saba.us"
fi
WEBMUX_IP=$(get_ip $WEBMUX_HOST)
if [[ -z "$WEBMUX_PORT" ]]; then
    WEBMUX_PORT=2000
fi
if [[ -z "$WEBMUX_SSH_KEY_FILE" ]]; then
    WEBMUX_SSH_KEY_FILE="$HOME/etc/secure/ssh/external/webmux_rsa"
    if ! decrypted "${WEBMUX_SSH_KEY_FILE}"; then
        echo "ERROR: Must decrypt webmux key!"
        exit 1
    fi
fi
chmod 0600 "$WEBMUX_SSH_KEY_FILE"

# Remove any previous webmux host keys
echo "Removing old webmux host keys..."
ssh-keygen -R $WEBMUX_HOST >/dev/null 2>/dev/null
ssh-keygen -R $WEBMUX_IP >/dev/null 2>/dev/null

KEYSCAN="|1|SAEjzVW6mdlzX+OtgBOZUQ3+/aA=|oX+zcTh4RBBtdsN7qut+l3WDWwc= ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBOkDbQ3Kkh9HvzWYaep7DaZaFM9zPp5dHqOr4nKD3vS1rJUT141UXSFL0E6GXlJ+mOmwCHuSioSq+dgok+ImaRY="
echo "Adding known-good webmux host key..."
echo "$KEYSCAN" >> "$HOME/.ssh/known_hosts"

# Find our own SSH fingerprint
FINGERPRINT=$(ssh-keyscan -H localhost 2>&1 | grep 'ecdsa-sha2-nistp256' | awk '{ print $3 }')
if [[ -z "$FINGERPRINT" ]]; then
    echo "ERROR: Could not find own fingerprint!"
    exit 1
fi

function qwhich()
{
    which "$@" 2>/dev/null
}

# Returns true (0) if we've got a `mosh-server` and a `socat` on the path
function can_mosh
{
    if [[ -n "$(qwhich mosh-server)" ]] && [[ -n "$(qwhich socat)" ]]; then
        return 0
    fi
    return 1
}

function get_port_mapping()
{
    MOSH_PATH=""
    if can_mosh; then
        MOSH_PATH="$(qwhich mosh-server)"
    fi
    JSON_DATA="{\
        \"user\":\"$USER\", \
        \"hostname\":\"$HOSTNAME\", \
        \"mosh_path\":\"$MOSH_PATH\", \
        \"fingerprint\":\"$FINGERPRINT\" \
    }"
    curl -# -H "Content-Type: application/json" -X POST -d "$JSON_DATA" -f -L "https://$WEBMUX_HOST/register"
}

function update_git_repo()
{
    UPDATE_URL=$(git remote get-url updates 2>/dev/null)
    if [[ -z "${UPDATE_URL}" ]]; then
        git remote add updates https://github.com/staticfloat/webmux.git
    fi

    git pull updates master
}

function webmux_reverse_tunnel()
{
    local SSH_OPTS=()
    SSH_PORT="$1"
    MOSH_PORT="$(($1 + 1000))"

    # When this subshell get a sigint, sigterm, returns or exits, call
    # `kill 0` to bring down the whole process tree, including `socat`.
    trap "exit" INT TERM RETURN
    trap "kill 0" EXIT

    # Set keyfile to use to login
    SSH_OPTS+=("-i${WEBMUX_SSH_KEY_FILE/#\~/$HOME}")

    # Tell SSH to quit if it can't start forwarding ports
    SSH_OPTS+=("-o ExitOnForwardFailure=yes")

    # Tell SSH to quit if heartbeats stop working for more than two minutes at a time
    SSH_OPTS+=("-o ServerAliveCountMax=2")
    SSH_OPTS+=("-o ServerAliveInterval=60")

    # Create port forwarding for SSH
    SSH_OPTS+=("-R $SSH_PORT:localhost:22")

    # Operate on the WEBMUX_PORT
    SSH_OPTS+=("-p $WEBMUX_PORT")

    # Don't ask for a tty
    SSH_OPTS+=("-N")

    # If we can tunnel mosh, then start up a socat instance running on here to
    # parrot incoming UDP-over-TCP packets to our mosh instance
    if can_mosh; then
        SSH_OPTS+=("-R $MOSH_PORT:localhost:$MOSH_PORT")

        # Immediately spawn off our own socat to do the local parroting
        socat tcp4-listen:$MOSH_PORT,reuseaddr,fork udp:localhost:$MOSH_PORT &
    fi

    # Put in server address and execute!
    "$(which ssh)" "${SSH_OPTS[@]}" "webmux@$WEBMUX_HOST"
}

PORT_NUMBER=$(get_port_mapping)
if [[ -z "$PORT_NUMBER" ]]; then
    echo "ERROR: Could not get port mapping, waiting 10 seconds and trying again..."
    sleep 10
else
    echo "Connecting to claim port $PORT_NUMBER..."
    (webmux_reverse_tunnel $PORT_NUMBER)
    sleep 1
fi

# Always, at the end of all things, git pull the latest and re-exec ourselves
update_git_repo
exec "./webmux_client"
